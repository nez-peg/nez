package nez.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;

import nez.NezOption;
import nez.lang.And;
import nez.lang.AnyChar;
import nez.lang.Block;
import nez.lang.ByteChar;
import nez.lang.ByteMap;
import nez.lang.Capture;
import nez.lang.CharMultiByte;
import nez.lang.Choice;
import nez.lang.DefIndent;
import nez.lang.DefSymbol;
import nez.lang.ExistsSymbol;
import nez.lang.Expression;
import nez.lang.Grammar;
import nez.lang.IsIndent;
import nez.lang.IsSymbol;
import nez.lang.Link;
import nez.lang.LocalTable;
import nez.lang.New;
import nez.lang.NonTerminal;
import nez.lang.Not;
import nez.lang.Option;
import nez.lang.Production;
import nez.lang.Repetition;
import nez.lang.Repetition1;
import nez.lang.Replace;
import nez.lang.Sequence;
import nez.lang.Tagging;
import nez.util.StringUtils;
import nez.util.UList;

public class PythonParserGenerator extends NezGenerator {

	@Override
	public String getDesc() {
		return "a Nez parser generator for Python (sample)";
	}

	@Override
	public void makeHeader(Grammar g) {
		W("# This file is generated by the Nez Python parser generator");
		Import("sys");
		Import("time");
		L().Func("sys.path.append", "'libnez/py/'");
		FromImport("libnez", "*");
		L();
	}

	@Override
	public void makeFooter(Grammar g) {
		Let("argvs", "sys.argv");
		Let("argc", "len(argvs)");
		If("argc != 2").Begin().Print("Usage: python [parser_file] [input_file]").Quit().End();
		Let("f", _func("open", "argvs[1]", "'r'"));
		Let("inputs", _func("''.join", _func("f.readlines", "")));
		Let("length", _func("len", "inputs") + " - 1");
		Let("inputs", "inputs + '\\0'");
		Let("compiler", _func("ASTMachineCompiler", ""));
		Let("memoTable", _func("ElasticTable", "32", String.valueOf(memoPoint)));
		Let("parser", _func("PyNez", "inputs", "compiler, memoTable"));
		Let("start", "time.clock()");
		L("r = ").Func("parser.pFile", "True");
		L().Func("compiler.encode", "Instruction.Iret", "0", "None");
		If("r == False").Begin().Print("parse error!!").End();
		// ElIf("parser.pos != length").Begin().Print("unconsume!!").End();
		Else().Begin().Let("end", "time.clock()").Print("time = {0}[sec]", "(end - start)").Print("match!!");
		Let("machine", _func("ASTMachine", "inputs"));
		Print("\\nAST Construction:\\n");
		Let("ast", _func("machine.commitLog", "compiler.func"));
		L().Func("ast.dump", "");
		End();
	}

	@Override
	public void generate(Grammar grammar, NezOption option, String fileName) {
		this.setOption(option);
		this.setOutputFile(fileName);
		makeHeader(grammar);
		Class("PyNez").Begin();
		makeParserClass();
		for(Production p : grammar.getProductionList()) {
			visitProduction(p);
		}
		makeByteMap();
		End();
		makeFooter(grammar);
		file.writeNewLine();
		file.flush();
	}

	protected void makeParserClass() {
		FuncDef("__init__", "self", "inputs, compiler, memoTable").Begin();
		Let("self.pos", "0");
		Let("self.inputs", "inputs");
		Let("self.inputSize", _func("len", "inputs"));
		Let("self.compiler", "compiler");
		Let("self.memoTable", "memoTable");
		End().L();
		FuncDef("charInputAt", "self").Begin();
		If("self.inputSize == self.pos").Begin().Return("None").End();
		Return("self.inputs[self.pos]").End().L();
		FuncDef("matchCharMap", "self", "map").Begin();
		Let("ch", "self.charInputAt()");
		If("ch is not None").Begin();
		If("map[ord(ch)] == True").Begin().Consume().Return("True").End();
		End();
		Return("False").End().L();
	}

	protected void makeByteMap() {
		for(ByteMap map : this.byteMapList) {
			L("map").W(String.valueOf(map.getId())).W(" = [");
			for(int i = 0; i < map.byteMap.length; i++) {
				if(map.byteMap[i]) {
					W("True");
				} else {
					W("False");
				}
				if(i != map.byteMap.length - 1) {
					W(", ");
				}
			}
			W("]").L();
		}
	}

	protected PythonParserGenerator W(String word) {
		file.write(word);
		return this;
	}

	protected PythonParserGenerator L() {
		file.writeIndent();
		return this;
	}

	protected PythonParserGenerator L(String line) {
		file.writeIndent(line);
		return this;
	}

	protected PythonParserGenerator Begin() {
		file.incIndent();
		return this;
	}

	protected PythonParserGenerator End() {
		file.decIndent();
		return this;
	}

	protected PythonParserGenerator Import(String name) {
		L("import ").W(name);
		return this;
	}

	protected PythonParserGenerator FromImport(String packageName, String name) {
		L("from ").W(packageName).W(" import ").W(name);
		return this;
	}

	protected PythonParserGenerator Class(String name) {
		L("class ").W(name).W(":");
		return this;
	}

	protected String _func(String name, String... args) {
		StringBuilder sb = new StringBuilder();
		sb.append(name).append("(");
		for(int i = 0; i < args.length; i++) {
			sb.append(args[i]);
			if(i != args.length - 1) {
				sb.append(", ");
			}
		}
		sb.append(")");
		return sb.toString();
	}

	protected PythonParserGenerator FuncDef(Production p, String... args) {
		L("def p").W(p.getLocalName()).W("(");
		for(int i = 0; i < args.length; i++) {
			W(args[i]);
			if(i != args.length - 1) {
				W(", ");
			}
		}
		W("):");
		return this;
	}

	protected PythonParserGenerator FuncDef(String name, String... args) {
		L("def ").W(name).W("(");
		for(int i = 0; i < args.length; i++) {
			W(args[i]);
			if(i != args.length - 1) {
				W(", ");
			}
		}
		W("):");
		return this;
	}

	protected PythonParserGenerator Func(String name, String... args) {
		W(name).W("(");
		for(int i = 0; i < args.length; i++) {
			W(args[i]);
			if(i != args.length - 1) {
				W(", ");
			}
		}
		W(")");
		return this;
	}

	protected PythonParserGenerator Return(String ret) {
		L("return ").W(ret);
		return this;
	}

	protected PythonParserGenerator Break() {
		L("break");
		return this;
	}

	protected PythonParserGenerator Pass() {
		L("pass");
		return this;
	}

	protected PythonParserGenerator Let(String var, String e) {
		L(var).W(" = ").W(e);
		return this;
	}

	protected PythonParserGenerator While(String cond) {
		L("while ").W(cond).W(":");
		return this;
	}

	protected PythonParserGenerator If(String cond) {
		L("if ").W(cond).W(":");
		return this;
	}

	protected PythonParserGenerator ElIf(String cond) {
		L("elif ").W(cond).W(":");
		return this;
	}

	protected PythonParserGenerator Else() {
		L("else").W(":");
		return this;
	}

	protected PythonParserGenerator Print(String str) {
		L("print('").W(str).W("')");
		return this;
	}

	protected PythonParserGenerator Print(String str, String val) {
		L("print(\"").W(str).W("\".format(" + val + "))");
		return this;
	}

	protected PythonParserGenerator Quit() {
		L("quit()");
		return this;
	}

	protected PythonParserGenerator Inc(String val) {
		W(val).W(" += ").W("1");
		return this;
	}

	protected PythonParserGenerator Dec(String val) {
		W(val).W(" -= ").W("1");
		return this;
	}

	protected PythonParserGenerator Consume() {
		L().Inc("self.pos");
		return this;
	}

	protected PythonParserGenerator Fail() {
		Let("result", "False");
		return this;
	}

	protected PythonParserGenerator Succ() {
		Let("result", "True");
		return this;
	}

	protected String _match(String str) {
		return "self.inputs[self.pos]" + "== " + str;
	}

	protected PythonParserGenerator Inew() {
		L().Func("self.compiler.encode", "Instruction.Inew", "self.pos", "None");
		return this;
	}

	protected PythonParserGenerator Ileftnew() {
		L().Func("self.compiler.encode", "Instruction.Ileftnew", "self.pos", "0");
		return this;
	}

	protected PythonParserGenerator Icapture() {
		L().Func("self.compiler.encode", "Instruction.Icapture", "self.pos", "None");
		return this;
	}

	protected PythonParserGenerator Ileftcapture() {
		L().Func("self.compiler.encode", "Instruction.Ileftcapture", "self.pos", "None");
		return this;
	}

	protected PythonParserGenerator Ilink(int index) {
		L().Func("self.compiler.encode", "Instruction.Ilink", "0", String.valueOf(index));
		return this;
	}

	protected PythonParserGenerator Itag(String tag) {
		L().Func("self.compiler.encode", "Instruction.Itag", "0", "'" + tag + "'");
		return this;
	}

	protected PythonParserGenerator Ireplace(String value) {
		L().Func("self.compiler.encode", "Instruction.Ireplace", "0", "'" + value + "'");
		return this;
	}

	protected PythonParserGenerator Icall(String inst) {
		L().Let(inst, _func("self.compiler.encode", "Instruction.Icall", "0", "None"));
		return this;
	}

	protected PythonParserGenerator Iret() {
		L().Func("self.compiler.encode", "Instruction.Iret", "0", "None");
		return this;
	}

	protected PythonParserGenerator Abort() {
		L().Func("self.compiler.abort", "");
		return this;
	}

	protected PythonParserGenerator Abort(String arg) {
		L().Func("self.compiler.abortFunc", arg);
		return this;
	}

	protected PythonParserGenerator Lookup(int memoPoint) {
		Let("m", _func("self.memoTable.getMemo", "self.pos", String.valueOf(memoPoint)));
		If("m is not None").Begin();
		If("m.failed").Begin().Let("result", "False").End();
		Else().Begin();
		Let("self.pos", "self.pos + m.consumed");
		L("self.memoTable.stat.Used += 1");
		Print("memoHit");
		End();
		End();
		return this;
	}

	protected PythonParserGenerator LookupNode(int memoPoint, int index) {
		Let("m", _func("self.memoTable.getMemo", "self.pos", String.valueOf(memoPoint)));
		If("m is not None").Begin();
		If("m.failed").Begin().Let("result", "False").End();
		Else().Begin();
		L().Func("self.compiler.func.list.append", "m.inst");
		Ilink(index);
		Let("self.pos", "self.pos + m.consumed");
		L("self.memoTable.stat.Used += 1");
		End();
		End();
		return this;
	}

	protected PythonParserGenerator Memoize(int memoPoint, String pos) {
		L().Func("self.memoTable.setMemo", pos, String.valueOf(memoPoint), "not result", "None", "self.pos -" + pos);
		return this;
	}

	protected PythonParserGenerator MemoizeNode(int memoPoint, String pos, String inst) {
		L().Func("self.memoTable.setMemo", pos, String.valueOf(memoPoint), "not result", inst, "self.pos -" + pos);
		return this;
	}

	@Override
	public void visitProduction(Production r) {
		FuncDef(r, "self", "result").Begin();
		visitExpression(r.getExpression());
		Return("result").End().L();
	}

	@Override
	public void visitEmpty(Expression p) {
		Pass();
	}

	@Override
	public void visitFailure(Expression p) {
		Fail();
	}

	@Override
	public void visitAnyChar(AnyChar p) {
		If("self.inputs[self.pos] != '\\0'").Begin().Consume().End().Else().Begin().Fail().End();
	}

	@Override
	public void visitByteChar(ByteChar p) {
		If(_match(StringUtils.stringfyCharacter(p.byteChar))).Begin().Consume().End().Else().Begin().Fail().End();
	}

	ArrayList<ByteMap> byteMapList = new ArrayList<ByteMap>();

	@Override
	public void visitByteMap(ByteMap p) {
		if(!byteMapList.contains(p)) {
			byteMapList.add(p);
		}
		If("self.map" + p.getId() + "[ord(self.inputs[self.pos])]").Begin().Consume().End();
		Else().Begin().Fail().End();
	}

	@Override
	public void visitOption(Option p) {
		String pos = "pos_op" + p.getId();
		Let(pos, "self.pos");
		visitExpression(p.get(0));
		If("not result").Begin().Let("self.pos", pos).Succ().End();
	}

	@Override
	public void visitRepetition(Repetition p) {
		String pos = "pos_op" + p.getId();
		While("result").Begin();
		Let(pos, "self.pos");
		visitExpression(p.get(0));
		If("not result").Begin().Break().End();
		End();
		Let("self.pos", pos).Succ();
	}

	@Override
	public void visitRepetition1(Repetition1 p) {
		visitExpression(p.get(0));
		If("result").Begin();
		String pos = "pos_op" + p.getId();
		While("result").Begin();
		Let(pos, "self.pos");
		visitExpression(p.get(0));
		If("not result").Begin().Break().End();
		End();
		Let("self.pos", pos).Succ();
		End();
	}

	@Override
	public void visitAnd(And p) {
		String pos = "pos_and" + p.getId();
		Let(pos, "self.pos");
		visitExpression(p.get(0));
		Let("self.pos", pos);
	}

	@Override
	public void visitNot(Not p) {
		String pos = "pos_not" + p.getId();
		Let(pos, "self.pos");
		visitExpression(p.get(0));
		Let("self.pos", pos);
		If("result").Begin().Fail().End();
		Else().Begin().Succ().End();
	}

	public void flattenSequence(Sequence seq, UList<Expression> l) {
		Expression first = seq.getFirst();
		Expression last = seq.getNext();
		if(first instanceof Sequence) {
			flattenSequence((Sequence) first, l);
			if(last instanceof Sequence) {
				flattenSequence((Sequence) last, l);
				return;
			}
			l.add(last);
			return;
		}
		l.add(first);
		if(last instanceof Sequence) {
			flattenSequence((Sequence) last, l);
			return;
		}
		l.add(last);
	}

	@Override
	public void visitSequence(Sequence p) {
		Let("index" + p.getId(), _func("len", "self.compiler.func.list"));
		boolean isLeftNew = false;
		boolean isLink = false;
		UList<Expression> list = new UList<>(new Expression[p.size()]);
		flattenSequence(p, list);
		System.out.println(list.toString());
		for(int i = 0; i < list.size(); i++) {
			If("result").Begin();
			if(list.get(i) instanceof New) {
				if(((New) list.get(i)).lefted) {
					isLeftNew = true;
				}
			}
			if(list.get(i) instanceof Link) {
				isLink = true;
			}
			visitExpression(list.get(i));
		}
		for(int i = list.size(); i > 0; i--) {
			End();
		}
		if(isLeftNew) {
			If("not result").Begin().Abort().End();
		} else if(isLink) {
			If("not result").Begin().Abort("index" + p.getId()).End();
		}
		isLeftNew = false;
	}

	@Override
	public void visitChoice(Choice p) {
		String pos = "pos_c" + p.getId();
		Let(pos, "self.pos");
		for(int i = 0; i < p.size(); i++) {
			visitExpression(p.get(i));
			if(i < p.size() - 1) {
				If("not result").Begin().Let("self.pos", pos).Succ();
			}
		}
		for(int i = 0; i < p.size() - 1; i++) {
			End();
		}
	}

	HashMap<Integer, Integer> memoMap = new HashMap<Integer, Integer>();
	int memoPoint = 0;

	@Override
	public void visitNonTerminal(NonTerminal p) {
		Production rule = p.getProduction();
		if(rule.isNoNTreeConstruction()) {
			int memoPoint = 0;
			if(!memoMap.containsKey(p.getId())) {
				memoPoint = this.memoPoint++;
				this.memoMap.put(p.getId(), memoPoint);
			} else {
				memoPoint = memoMap.get(p.getId());
			}
			Lookup(memoPoint);
			Else().Begin();
			Let("pos" + p.getId(), "self.pos");
			Let("result", _func("self.p" + p.getLocalName(), "result"));
			Memoize(memoPoint, "pos" + p.getId());
			End();
		} else {
			Let("result", _func("self.p" + p.getLocalName(), "result"));
		}
	}

	@Override
	public void visitLink(Link p) {
		int memoPoint = 0;
		if(!memoMap.containsKey(p.getId())) {
			memoPoint = this.memoPoint++;
			this.memoMap.put(p.getId(), memoPoint);
		} else {
			memoPoint = memoMap.get(p.getId());
		}
		LookupNode(memoPoint, p.index);
		Else().Begin();
		String inst = "inst" + p.getId();
		String pos = "pos" + p.getId();
		Let(pos, "self.pos");
		Icall(inst);
		visitExpression(p.get(0));
		If("result").Begin().Iret().Ilink(p.index).MemoizeNode(memoPoint, pos, inst).End();
		Else().Begin().Abort().MemoizeNode(memoPoint, pos, "None").End();
		// If("result").Begin().Iret().Ilink(p.index).End();
		// Else().Begin().Abort().End();
		End();
	}

	Stack<Boolean> markStack = new Stack<Boolean>();

	@Override
	public void visitNew(New p) {
		if(p.lefted) {
			Ileftnew();
			markStack.push(true);
		} else {
			Inew();
			markStack.push(false);
		}
	}

	@Override
	public void visitCapture(Capture p) {
		if(markStack.pop()) {
			If("result").Begin().Ileftcapture().End();
			Else().Begin().Abort().End();
		} else {
			Icapture();
		}
	}

	@Override
	public void visitTagging(Tagging p) {
		Itag(p.getTagName());
	}

	@Override
	public void visitReplace(Replace p) {
		Ireplace(p.value);
	}

	@Override
	public void visitBlock(Block p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitDefSymbol(DefSymbol p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitIsSymbol(IsSymbol p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitDefIndent(DefIndent p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitIsIndent(IsIndent p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitExistsSymbol(ExistsSymbol p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitLocalTable(LocalTable p) {
		// TODO Auto-generated method stub

	}

	@Override
	public void visitCharMultiByte(CharMultiByte p) {
		// TODO Auto-generated method stub

	}

}
