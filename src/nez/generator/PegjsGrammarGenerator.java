package nez.generator;

import nez.lang.And;
import nez.lang.AnyChar;
import nez.lang.ByteChar;
import nez.lang.ByteMap;
import nez.lang.Capture;
import nez.lang.Choice;
import nez.lang.Expression;
import nez.lang.Grammar;
import nez.lang.Link;
import nez.lang.New;
import nez.lang.NonTerminal;
import nez.lang.Not;
import nez.lang.Option;
import nez.lang.Production;
import nez.lang.Repetition;
import nez.lang.Repetition1;
import nez.lang.Replace;
import nez.lang.Sequence;
import nez.lang.Tagging;

public class PegjsGrammarGenerator extends GrammarGenerator {

	@Override
	public String getDesc() {
		return "generate a PEGjs Grammar";
	}

	@Override
	public void makeHeader(Grammar g) {
		L("// The following is generated by the Nez Grammar Generator ");

	}

	@Override
	public void makeFooter(Grammar g) {

	}

	@Override
	protected String _NonTerminal(Production p) {
		return p.getLocalName();
	}

	@Override
	protected String _Open() {
		return "<";
	};

	@Override
	protected String _Close() {
		return ">";
	};

	@Override
	protected String _Delim() {
		return ",";
	};

	@Override
	public void visitGrouping(Expression e) {
		W(_OpenGrouping());
		visitExpression(e);
		W(_CloseGrouping());
	}

	@Override
	public void visitProduction(Production p) {
		Expression e = p.getExpression();
		L(_NonTerminal(p));
		inc();
		L("= ");
		visitExpression(e);
		L();
		dec();
	}

	@Override
	public void visitEmpty(Expression e) {
	}

	@Override
	public void visitFailure(Expression e) {
	}

	@Override
	public void visitNonTerminal(NonTerminal e) {
		W("" + _NonTerminal(e.getProduction()));
	}

	public String stringfyByte(int byteChar) {
		char c = (char)byteChar;
		switch(c) {
		case '\n':
			return ("'\\n'");
		case '\t':
			return ("'\\t'");
		case '\r':
			return ("'\\r'");
		case '\"':
			return ("\"\\\"\"");
		case '\\':
			return ("'\\\\'");
		}
		return "\"" + c + "\"";
	}

	@Override
	public void visitByteChar(ByteChar e) {
		W(this.stringfyByte(e.byteChar));
	}

	private int searchEndChar(boolean[] b, int s) {
		for(; s < 256; s++) {
			if(!b[s]) {
				return s - 1;
			}
		}
		return 255;
	}

	private void getRangeChar(byte ch, StringBuilder sb) {
		char c = (char)ch;
		switch(c) {
		case '\n':
			sb.append("\\n");
			break;
		case '\t':
			sb.append("'\\t'");
			break;
		case '\r':
			sb.append("'\\r'");
			break;
		case '\'':
			sb.append("'\\''");
			break;
		case '\"':
			sb.append("\"");
			break;
		case '\\':
			sb.append("'\\\\'");
			break;
		}
		sb.append(c);
	}

	@Override
	public void visitByteMap(ByteMap e) {
		W("[");
		boolean b[] = e.byteMap;
		for(int start = 0; start < 256; start++) {
			if(b[start]) {
				int end = searchEndChar(b, start + 1);
				if(start == end) {
					W(this.stringfyByte(start));
				}
				else {
					StringBuilder sb = new StringBuilder();
					getRangeChar((byte)start, sb);
					sb.append("-");
					getRangeChar((byte)end, sb);
					W(sb.toString());
					start = end;
				}
			}
		}
		W("]");
	}

	@Override
	public void visitString(String s) {
	}

	@Override
	public void visitAnyChar(AnyChar e) {
		W(".");
	}

	@Override
	public void visitOption(Option e) {
		for(Expression sub : e) {
			visitExpression(sub);
		}
		W("?");
	}

	@Override
	public void visitRepetition(Repetition e) {
		for(Expression sub : e) {
			visitExpression(sub);
		}
		W("*");
	}

	@Override
	public void visitRepetition1(Repetition1 e) {
		for(Expression sub : e) {
			visitExpression(sub);
		}
		W("+");
	}

	@Override
	public void visitAnd(And e) {
		W("&");
		for(Expression sub : e) {
			visitExpression(sub);
		}
	}

	@Override
	public void visitNot(Not e) {
		W("!");
		for(Expression sub : e) {
			visitExpression(sub);
		}
	}

	@Override
	public void visitChoice(Choice e) {
		int checkFirst = 0;
		W("(");
		for(Expression sub : e) {
			if(checkFirst > 0) {
				L("/ ");
			}
			visitExpression(sub);
			checkFirst++;
		}
		W(")");
	}

	@Override
	public void visitSequence(Sequence e) {
		W("(");
		for(Expression sub : e) {
			visitExpression(sub);
			W(" ");
		}
		W(")");
	}

	@Override
	public void visitNew(New e) {
		for(Expression sub : e) {
			visitExpression(sub);
		}
	}

	@Override
	public void visitCapture(Capture e) {
	}

	@Override
	public void visitTagging(Tagging e) {
	}

	@Override
	public void visitReplace(Replace e) {
	}

	@Override
	public void visitLink(Link e) {
		// if(e.index != -1) {
		// C("Link", String.valueOf(e.index), e);
		// }
		// else {
		// C("Link", e);
		// }
		visitExpression(e.get(0));
	}

	@Override
	public void visitUndefined(Expression e) {
		if(e.size() > 0) {
			visitExpression(e.get(0));
		}
		else {
		}
		// W("<");
		// W(e.getPredicate());
		// for(Expression se : e) {
		// W(" ");
		// visit(se);
		// }
		// W(">");
	}

}
